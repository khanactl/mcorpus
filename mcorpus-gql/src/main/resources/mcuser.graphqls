# mcuser queries
extend type Query {

  # jwt login status
  jwtStatus: JwtStatus!

  # get an mcuser and assigned roles
  getMcuser(uid: ID!): Mcuser @auth(role: "admin")

  # mcuser history of activity
  mchistory(uid: ID!): McuserHistory @auth(role: "admin")
}

# mcuser mutation methods
extend type Mutation {

  # JWT login - upon successful login a new jwt is issued
  jwtLogin(username: String!, pswd: String!): Boolean!

  # JWT logout - invalidate the active jwt
  jwtLogout: Boolean!

  # invalidate all active JWTs issued to a the given user
  invalidateJwts(jwtUserId: ID!): Boolean @auth(role: "admin")

  # set/reset an mucser pswd by mcuser id
  mcpswd(uid: ID!, pswd: String!): Boolean @auth(role: "admin")

  # add a new mcuser to the system
  addMcuser(mcuser: McuserToAdd!): Mcuser @auth(role: "admin")

  # update an existing mcuser
  updateMcuser(mcuser: McuserToUpdate!): Mcuser @auth(role: "admin")

  # physically remove an mcuser entirely from the system
  deleteMcuser(uid: ID!): Boolean @auth(role: "admin")
}

# details of a single JWT
type JwtInfo {
  # the JWT id
  jwtId: ID
  # when the JWT was created
  created: Date
  # when the JWT expires
  expires: Date
  # the resolved ip address of the sourcing http request that created the JWT
  clientOrigin: String
}

# the status of the active JWT
type JwtStatus {
  # the JWT id
  jwtId: ID
  # the JWT user id
  jwtUserId: ID
  # when the JWT was created
  created: Date
  # when the JWT expires
  expires: Date
  # the JWT roles claim
  roles: String
  # list of all valid and non-expired JWTs presently issued to the bound jwt user (mcuser)
  activeJWTs: [JwtInfo]
}

# mcuser - those granted access to the mcorpus graphql api
type Mcuser {
  # the mcuser id (jwt id)
  uid: ID
  # mcuser creation date
  created: Date
  # mcuser last modified date
  modified: Date
  # mcuser name
  name: String
  # mcuser email address
  email: String
  # mcuser username
  username: String
  # mcuser status
  status: McuserStatus
  # the assigned mcuser roles
  roles: [McuserRole]
}

# login and logout history of an mcuser
type McuserHistory {
  # the mcuser id
  uid: ID
  # the mcuser login history
  logins: [McuserLoginEvent]
  # the mcuser logout history
  logouts: [McuserLogoutEvent]
}

# a single mcuser login event
type McuserLoginEvent {
  # the JWT id
  jwtId: ID
  # the login timestamp
  timestamp: Date
  # the resolved ip address of the sourcing http request associated with the login event
  clientOrigin: String
}

# a single mcuser logout event
type McuserLogoutEvent {
  # the JWT id
  jwtId: ID
  # the logout timestamp
  timestamp: Date
  # the resolved ip address of the sourcing http request associated with the logout event
  clientOrigin: String
}

# mcuser status
enum McuserStatus {
  # mcuser active
  ACTIVE
  # mcuser inactive (No mcorpus api interaction allowed)
  INACTIVE
}

# the allowed roles an mcuser may have
enum McuserRole {
  # mcorpus - full read and write over all members
  MCORPUS
  # member - member login and logout capability
  MEMBER
  # mpii - ability for non-admins to see member PII fields
  MPII
  # admin - only an mcuser admininstrator may invoke the bound operation
  ADMIN
}

# required properties for adding a new mcuser
input McuserToAdd {
  # mcuser name
  name: String!
  # mcuser email address
  email: String!
  # mcuser username
  username: String!
  # mcuser password
  pswd: String!
  # mcuser initial status
  initialStatus: McuserStatus!
  # the optional mcuser roles to set
  roles: [McuserRole]
}

# required properties for updating an existing mcuser
input McuserToUpdate {
  # the id of the mcuser to update
  uid: ID!
  # mcuser name
  name: String
  # mcuser email address
  email: String
  # mcuser username
  username: String
  # mcuser status
  status: McuserStatus
  # the optional mcuser roles to set where, if specified, forces existing roles to first be deleted
  roles: [McuserRole]
}
